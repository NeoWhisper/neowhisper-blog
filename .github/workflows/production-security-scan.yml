name: Production Security Scan

on:
  schedule:
    - cron: "0 0 * * 1" # Weekly on Monday at 00:00 UTC
  push:
    branches: [main]
  workflow_dispatch: {}

jobs:
  scan:
    runs-on: ubuntu-latest

    # Minimal permissions: can read repo contents and write issues
    permissions:
      contents: read
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Run production security checks
        id: run_scan
        run: |
          set -euo pipefail

          BASE="https://www.neowhisper.net"
          mkdir -p artifacts
          LOG="artifacts/scan.log"
          SUMMARY="artifacts/scan-summary.txt"

          failures=0

          # Header and intro
          {
            printf 'Production security scan: %s\n' "$(date -u)"
            printf '\n-- Checking root (/) headers --\n'
          } | tee "$LOG"
          printf 'Production security scan: %s\n' "$(date -u)" > "$SUMMARY"

          # --- Root (/) headers ---
          curl -s -D - -o /dev/null -L -H "Origin: https://example.com" "$BASE/" | tee -a "$LOG" > /tmp/headers_root.txt

          grep -iq "x-content-type-options: *nosniff" /tmp/headers_root.txt || {
            echo "Missing or incorrect X-Content-Type-Options" | tee -a "$LOG"
            echo "MISSING: X-Content-Type-Options" >> "$SUMMARY"
            failures=$((failures+1))
          }

          grep -iq "x-frame-options: *deny" /tmp/headers_root.txt || {
            echo "Missing or incorrect X-Frame-Options" | tee -a "$LOG"
            echo "MISSING: X-Frame-Options" >> "$SUMMARY"
            failures=$((failures+1))
          }

          grep -iq "content-security-policy:.*default-src 'self'" /tmp/headers_root.txt || {
            echo "Missing or weak Content-Security-Policy (default-src 'self' not present)" | tee -a "$LOG"
            echo "MISSING: Content-Security-Policy (default-src 'self')" >> "$SUMMARY"
            failures=$((failures+1))
          }

          # --- /robots.txt (ACAO absent) ---
          printf '\n-- Checking /robots.txt (ACAO absent) --\n' | tee -a "$LOG"
          curl -s -D - -o /dev/null -L -H "Origin: https://example.com" "$BASE/robots.txt" | tee -a "$LOG" > /tmp/headers_robots.txt

          if grep -iq "access-control-allow-origin" /tmp/headers_robots.txt; then
            robots_acao=$(grep -i "access-control-allow-origin" /tmp/headers_robots.txt | head -n 1 | awk -F: '{print $2}' | tr -d ' \r')
            if [ -n "$robots_acao" ]; then
              echo "Warning: Access-Control-Allow-Origin header on robots.txt (tolerated on CDNs)" | tee -a "$LOG"
              echo "WARN: Access-Control-Allow-Origin on robots.txt" >> "$SUMMARY"
            else
              echo "Access-Control-Allow-Origin present but empty on robots.txt (accepted)" | tee -a "$LOG"
              echo "OK: ACAO empty on robots.txt" >> "$SUMMARY"
            fi
          fi

          # --- /sitemap.xml (ACAO absent) ---
          printf '\n-- Checking /sitemap.xml (ACAO absent) --\n' | tee -a "$LOG"
          curl -s -D - -o /dev/null -L -H "Origin: https://example.com" "$BASE/sitemap.xml" | tee -a "$LOG" > /tmp/headers_sitemap.txt

          if grep -iq "access-control-allow-origin" /tmp/headers_sitemap.txt; then
            sitemap_acao=$(grep -i "access-control-allow-origin" /tmp/headers_sitemap.txt | head -n 1 | awk -F: '{print $2}' | tr -d ' \r')
            if [ -n "$sitemap_acao" ]; then
              echo "Warning: Access-Control-Allow-Origin header on sitemap.xml (tolerated on CDNs)" | tee -a "$LOG"
              echo "WARN: Access-Control-Allow-Origin on sitemap.xml" >> "$SUMMARY"
            else
              echo "Access-Control-Allow-Origin present but empty on sitemap.xml (accepted)" | tee -a "$LOG"
              echo "OK: ACAO empty on sitemap.xml" >> "$SUMMARY"
            fi
          fi

          # --- OCSP stapling ---
          printf '\n-- Checking OCSP stapling --\n' | tee -a "$LOG"
          HOST=$(echo "$BASE" | sed -E 's#https?://##')

          # Capture OCSP response via openssl; include output in logs for triage (kept local only)
          openssl s_client -status -connect "$HOST:443" -servername "$HOST" </dev/null 2>&1 | tee -a "$LOG" > /tmp/ocsp.txt || true

          if grep -iq "OCSP response: no response sent" /tmp/ocsp.txt || ! grep -iq "OCSP Response" /tmp/ocsp.txt; then
            echo "OCSP stapling appears disabled or no OCSP response was obtained (warning only)" | tee -a "$LOG"
            echo "WARN: OCSP stapling not detected" >> "$SUMMARY"
          else
            echo "OCSP stapling appears enabled" | tee -a "$LOG"
            echo "OK: OCSP stapling" >> "$SUMMARY"
          fi

          # --- Summary ---
          printf '\n-- Summary --\n' | tee -a "$LOG"
          {
            echo ""
            echo "SUMMARY (redacted):"
            cat "$SUMMARY"
          } >> "$LOG"

          {
            echo ""
            printf 'Scan completed at: %s\n' "$(date -u)"
          } >> "$SUMMARY"

          if [ "$failures" -gt 0 ]; then
            echo "Scan completed with $failures failures" | tee -a "$LOG"
            echo "RESULT: failures=$failures" >> "$SUMMARY"
            echo "success=false" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "All checks passed" | tee -a "$LOG"
            echo "RESULT: all-passed" >> "$SUMMARY"
            echo "success=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload redacted summary on failure
        if: failure()
        uses: actions/upload-artifact@v6
        with:
          name: production-security-scan-summary
          path: artifacts/scan-summary.txt

      - name: Open (or update) GitHub issue on failure (redacted summary only)
        if: failure()
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            const body = fs.readFileSync('artifacts/scan-summary.txt', 'utf8');
            const today = new Date().toISOString().slice(0, 10);
            const title = `Production security scan failed - ${today}`;
            const label = 'security-scan';

            // Ensure label exists (create if missing)
            try {
              await github.rest.issues.getLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: label,
              });
            } catch (err) {
              await github.rest.issues.createLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: label,
                color: 'b60205',
                description: 'Automated production security scan failures',
              });
            }

            // Find existing open issue with our label and matching title prefix
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: label,
            });

            const existing = issues.data.find(
              (i) => i.title && i.title.startsWith('Production security scan failed -')
            );

            const issueBody =
              'Automated security scan detected regressions.\n\n' +
              'Redacted summary (full raw logs are not posted publicly):\n\n' +
              '```\n' +
              body +
              '\n```\n\n' +
              'If you need full diagnostic logs, contact repository admins to request them.';

            if (existing) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body:
                  `Automated security scan detected regressions on ${new Date().toISOString()}.\n\n` +
                  'Redacted summary:\n\n' +
                  '```\n' +
                  body +
                  '\n```',
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body: issueBody,
                labels: [label],
              });
            }
