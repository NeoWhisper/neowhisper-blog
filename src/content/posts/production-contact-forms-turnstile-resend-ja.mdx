---
title: "Cloudflare TurnstileとResendで本番環境対応のお問い合わせフォームを構築する"
date: "2026-02-09"
excerpt: "スパムも配信エラーも回避。Turnstileでボット対策し、Resendで確実に届けるお問い合わせフォームの実装方法を、実際の経験から解説します。"
category: "Next.js"
coverImage: "/images/contact-form-cover.png"
author:
  name: "NeoWhisper"
  picture: "/images/author.png"
---

お問い合わせフォームは、本来シンプルなはずです。本番環境に公開するまでは。

公開した途端、スパムが押し寄せます。送信したメールが迷惑メールフォルダに入ります。空のフォームが送信されます。受信トレイがボットの投稿で溢れ、本物の問い合わせがゼロになります。

このサイトの[お問い合わせフォーム](/contact?lang=ja)を作り直したばかりなので、実際に機能するフォームの作り方を正確にお見せします。理論的な話ではなく、実際のユーザー（と実際のボット）がフォームを使い始めたときに重要なパターンだけを紹介します。

---

## 「シンプルな」お問い合わせフォームの問題点

基本的なお問い合わせフォームは簡単です：

```tsx
<form action="/api/contact" method="POST">
  <input name="email" />
  <textarea name="message" />
  <button>送信</button>
</form>
```

しかし、これは本番環境で壊れます：

1. **スパムボット**が公開から数時間で殺到する
2. **メール配信**が悪夢（Gmailがスパム扱いする）
3. **フィードバックがない**（サーバー側で失敗しても分からない）
4. **プログレッシブエンハンスメントゼロ**（JavaScriptなしで壊れる）

必要なものは3つ：
- 本物のスパム対策（2026年にボットが回避できるハニーポットではない）
- 信頼できるメール配信（SPF、DKIM、DMARCを正しく設定）
- 堅実なUX（JavaScriptの有無に関わらず動作）

---

## なぜCloudflare Turnstile + Resendなのか？

**Cloudflare Turnstile**は、GoogleトラッキングのないreCAPTCHAです。ほとんどのユーザーには見えず、妥当な量なら無料で、実際にボットを止めます。

**Resend**は、SendGrid/Mailgunのモダンな代替品です。クリーンなAPI、優れた配信性、リーズナブルな価格設定。

どちらもNext.jsに優しいAPIで、複雑なSDKセットアップは不要です。

---

## ステップ1: フォームにTurnstileを追加

まず、[Cloudflare](https://dash.cloudflare.com/?to=/:account/turnstile)からTurnstileサイトキーを取得します。

`.env.local`に追加：

```bash
NEXT_PUBLIC_TURNSTILE_SITE_KEY=your-site-key
TURNSTILE_SECRET_KEY=your-secret-key
```

次に、フォームにウィジェットを追加：

```tsx
'use client';

export default function ContactForm() {
  return (
    <form method="POST" action="/api/contact">
      <input name="name" required />
      <input name="email" type="email" required />
      <textarea name="details" required />
      
      {/* Turnstileチャレンジ */}
      <div 
        className="cf-turnstile"
        data-sitekey={process.env.NEXT_PUBLIC_TURNSTILE_SITE_KEY}
      />
      
      <button type="submit">送信</button>
      
      <Script 
        src="https://challenges.cloudflare.com/turnstile/v0/api.js" 
        async 
        defer 
      />
    </form>
  );
}
```

これでチャレンジウィジェットがレンダリングされます。Turnstileは自動的にフォーム送信に`cf-turnstile-response`トークンを追加します。

---

## ステップ2: サーバー側でトークンを検証

APIルート（`/api/contact/route.ts`）で、メールを送信する前にトークンを検証：

```tsx
export async function POST(request: Request) {
  const formData = await request.formData();
  const turnstileToken = formData.get('cf-turnstile-response');
  
  if (!turnstileToken) {
    return NextResponse.json(
      { ok: false, message: 'スパム検証に失敗しました。' },
      { status: 400 }
    );
  }
  
  // Cloudflareで検証
  const verifyResponse = await fetch(
    'https://challenges.cloudflare.com/turnstile/v0/siteverify',
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        secret: process.env.TURNSTILE_SECRET_KEY,
        response: turnstileToken,
      }),
    }
  );
  
  const verifyData = await verifyResponse.json();
  
  if (!verifyData.success) {
    console.error('Turnstile検証失敗:', verifyData);
    return NextResponse.json(
      { ok: false, message: 'スパム検証に失敗しました。' },
      { status: 400 }
    );
  }
  
  // トークンが有効、メール送信に進む
}
```

**重要なポイント:** 必ずサーバー側で検証してください。クライアントトークンは偽造可能です。

---

## ステップ3: Resendでメール送信

[Resend](https://resend.com/api-keys)からAPIキーを取得し、`.env.local`に追加：

```bash
RESEND_API_KEY=re_your_key_here
RESEND_FROM="Your Name <hello@yourdomain.com>"
RESEND_TO=your-inbox@example.com
```

次にメールを送信：

```tsx
const emailPayload = {
  from: process.env.RESEND_FROM,
  to: [process.env.RESEND_TO],
  subject: `${formData.get('name')}様からの新しい問い合わせ`,
  reply_to: formData.get('email'),
  text: `
    名前: ${formData.get('name')}
    メール: ${formData.get('email')}
    
    メッセージ:
    ${formData.get('details')}
  `,
};

const emailResponse = await fetch('https://api.resend.com/emails', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${process.env.RESEND_API_KEY}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(emailPayload),
});

if (!emailResponse.ok) {
  console.error('Resend APIエラー:', await emailResponse.text());
  return NextResponse.json(
    { ok: false, message: 'メール送信に失敗しました。' },
    { status: 500 }
  );
}

return NextResponse.json({ ok: true });
```

---

## ステップ4: メール配信性の修正（みんながスキップする部分）

メールを送信するのは簡単です。受信トレイに届けるのが難しいのです。

3つのDNSレコードが必要です：

### SPFレコード
DNSに追加（タイプ: TXT、ホスト: `@`）：

```
v=spf1 include:_spf.resend.com ~all
```

### DKIMレコード
Resendがダッシュボードで提供します。表示されたとおりにDNSに追加してください。

### DMARCレコード
DNSに追加（タイプ: TXT、ホスト: `_dmarc`）：

```
v=DMARC1; p=quarantine; rua=mailto:postmaster@yourdomain.com; pct=100; adkim=s; aspf=s
```

**なぜ重要か:** これらがないと、Gmail/Outlookはメールをスパムとしてマークするか、完全に拒否します。私は苦労して学びました—[お問い合わせフォーム](/contact?lang=ja)がDMARCを追加するまで数週間動作しませんでした。

[MXToolbox](https://mxtoolbox.com/)を使って、3つのレコードすべてが正しく設定されているか確認してください。

---

## ステップ5: プログレッシブエンハンスメント（JavaScriptなしで動作）

JavaScriptの読み込みに失敗してもフォームは動作すべきです。プラットフォームを使いましょう：

```tsx
<form method="POST" action="/api/contact">
  {/* フィールドをここに */}
</form>
```

APIルートで、HTMLフォーム送信かどうかを検出：

```tsx
const contentType = request.headers.get('content-type') ?? '';
const isFormSubmit = contentType.includes('application/x-www-form-urlencoded');

if (isFormSubmit) {
  // 成功/エラーメッセージ付きでリダイレクト
  return NextResponse.redirect(
    new URL('/contact?success=1&lang=ja', request.url),
    303
  );
}

// それ以外の場合、XHRリクエスト用にJSONを返す
return NextResponse.json({ ok: true });
```

これで、JavaScriptが無効な低速3Gのユーザーでも連絡できます。

---

## ステップ6: エラーを適切に処理

単に「何かが間違っていました」という汎用メッセージを返さないでください。具体的に：

```tsx
// 必須フィールドが欠けている
if (!name || !email || !details) {
  return json({ ok: false, message: '必須フィールドをすべて入力してください。' });
}

// メール形式が無効
if (!email.includes('@')) {
  return json({ ok: false, message: '有効なメールアドレスを入力してください。' });
}

// Turnstile失敗
if (!verifyData.success) {
  return json({ ok: false, message: 'セキュリティチェックを完了してください。' });
}

// メール送信失敗
if (!emailResponse.ok) {
  console.error('Resendエラー:', await emailResponse.text());
  return json({ ok: false, message: 'メッセージの送信に失敗しました。もう一度お試しいただくか、直接メールでご連絡ください。' });
}
```

これらのエラーをUIに表示して、ユーザーが何を修正すべきか分かるようにします。

---

## ステップ7: すべてをテスト

出荷前に：

1. **Turnstileをテスト:** チャレンジを完了せずに送信してみる
2. **バリデーションをテスト:** 空のフィールド、無効なメールなどを試す
3. **配信性をテスト:** Gmail、Outlook、Yahooに送信
4. **スパムヘッダーをチェック:** メールヘッダーでSPF/DKIM/DMARC PASSを確認
5. **JSなしでテスト:** JavaScriptを無効にしてフォームを送信
6. **失敗状態をテスト:** 一時的にAPIを壊してエラーメッセージを確認

---

## よくある落とし穴（と回避方法）

### 「メールがスパムに入る」
→ DNSレコードを確認してください。3つすべて（SPF、DKIM、DMARC）が正しくなければなりません。

### 「localhostでTurnstileが失敗する」
→ Turnstile設定で`localhost`を許可ドメインに追加してください。

### 「フォームを送信しても何も起こらない」
→ サーバーログを確認してください。Resendがキャッチしていないエラーを返しているかもしれません。

### 「ユーザーが送信できないと苦情」
→ Turnstileサイトキーがパブリックであることを確認してください（Next.jsでは`NEXT_PUBLIC_`プレフィックス）。

---

## これで得られるもの

この設定で：
- ✅ スパムゼロ（Turnstileがボットをブロック）
- ✅ メールが受信トレイに届く（適切なDNSレコード）
- ✅ JavaScriptなしで動作（プログレッシブエンハンスメント）
- ✅ 明確なエラーメッセージ（より良いUX）
- ✅ 保守が簡単（シンプルなAPIルート）

トータルのセットアップ時間は約2〜3時間ですが、一度完成すれば堅固です。

---

## さらに先へ

これが機能したら、以下を追加できます：
- レート制限（IPごとに1時間に1回の送信）
- Slack/Discordへのウェブフック通知
- 受信確認の自動返信メール
- コンバージョン率のアナリティクストラッキング

ただし、まずは基本を完璧にしましょう。動作するお問い合わせフォームは、派手で壊れたフォームに勝ります。

---

**サイトに本番環境対応のお問い合わせフォームを構築するサポートが必要ですか？** 私たちは、スパム対策からメール配信性まで、すべての詳細を処理したNext.js開発を専門としています。[サービス詳細](/services?lang=ja)をご覧いただくか、[お問い合わせ](/contact?lang=ja)からプロジェクトについてご相談ください。

---

**関連記事:** 多言語サイトを構築している場合は、適切なローカライズを備えた[AdSense対応Next.jsサイトの出荷ガイド](/blog/adsense-ready-multilingual-nextjs?lang=ja)もご覧ください。