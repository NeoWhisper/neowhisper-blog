---
title: "أفضل ممارسات TypeScript (بعيدًا عن التعقيد)"
date: "2026-01-29"
excerpt: "توقف عن مصارعة الـ Compiler. إليك كيف أجعل TypeScript يعمل لصالحي فعليًا في تطبيقات الـ Full-Stack."
category: "TypeScript"
coverImage: "/images/typescript-best-practices-cover.png"
author:
  name: "NeoWhisper"
  picture: "/images/author.png"
---

بصراحة، كنت أكره TypeScript.

كنت أشعر أنني أكتب كودًا فقط "لإرضاء" المترجم، بدلًا من بناء الميزات التي أحتاجها.

لكن بعد بناء عدة تطبيقات Full-Stack باستخدام Next.js، أدركت الحقيقة: **TypeScript هو الشيء الوحيد الذي يقف بينك وبين تلف قاعدة البيانات في الساعة الثالثة فجراً.**

المشكلة ليست في TypeScript. المشكلة هي أن معظم الدروس تعلمك كيف تكتب "الأنواع"، ولا تعلمك كيف تكتب "التطبيقات".

إليك كيف تتوقف عن التخمين وتجعل TypeScript يعمل لصالحك.

---

<Step number="١" title="شارك الأنواع بين الواجهة الأمامية والخلفية">

إذا كان لديك واجهة `User` في مجلد الفرونت-إند، ونسخة طبق الأصل منها في الباك-إند، فأنت تفعل ذلك بشكل خاطئ.

بمجرد أن يتغير أحدهما، سينكسر الآخر بصمت، وسترسل Bug للإنتاج.

**الحل:**
ضع نماذج البيانات الأساسية في مجلد مشترك.

```ts
// packages/types/src/user.ts
export interface User {
  id: string;
  email: string;
  role: "admin" | "user";
}
```

الآن استورد هذا الملف في كل مكان. إذا غيرت الـ `role`، سيتحول الكود للون الأحمر في المشروع كاملًا. هذه **ميزة**.

</Step>

<Step number="٢" title="وحّد شكل استجابات الـ API">

"ماذا يرجع هذا الرابط (Endpoint)؟"

إذا كانت إجابتك "أعتقد أنه كائن..."، فقد خسرت المعركة. اجبر كل Endpoint على إرجاع نفس الهيكل تمامًا.

```ts
// types/api.ts
export interface ApiResponse<T> {
  data: T;
  success: boolean;
  error?: string;
}
```

**الاستخدام:**

```ts
app.get("/users", async (req, res) => {
  const users = await db.users.findMany();

  // TypeScript سيجبرك على الالتزام بهذا الهيكل
  const response: ApiResponse<User[]> = {
    data: users,
    success: true,
  };

  res.json(response);
});
```

</Step>

<Step number="٣" title="لا تستخدم `any` في جلب البيانات">

أرى هذه "الجريمة" ترتكب يومياً:

```ts
// خطأ
const { data } = useQuery(["user"], fetchUser);
// data يعتبر 'any' أو 'unknown'
```

أنت بهذا الشكل تخليت عن كل فوائد TypeScript في اللحظة الأخيرة. افعل هذا بدلًا من ذلك:

```ts
// صحيح
function useUser(id: string) {
  return useQuery<User>({
    queryKey: ["user", id],
    queryFn: () => fetchUser(id),
  });
}
```

الآن عندما تكتب `data.`، المحرر يعرف بالضبط ما هي الحقول الموجودة.

</Step>

<Step number="٤" title="ثق، ولكن تحقق (Zod)">

TypeScript يختفي بمجرد تشغيل الكود (Runtime). إذا أرسل المستخدم بيانات JSON خاطئة، TypeScript لن ينقذك. **Zod** سينقذك.

استخدم Zod عند كل حدود الـ API.

```ts
import { z } from "zod";

const UserSchema = z.object({
  email: z.string().email(),
  age: z.number().min(18),
});

type UserInput = z.infer<typeof UserSchema>;

app.post("/users", (req, res) => {
  // سيرمي خطأ إذا كانت البيانات غير مطابقة
  const body = UserSchema.parse(req.body);

  saveUser(body);
});
```

هذه هي المنطقة المثالية: **أمان أثناء التشغيل** (Zod) + **أمان أثناء الكتابة** (TypeScript).

</Step>

---

## القائمة النهائية

لا تحتاج لتعقيدات الـ Generics لتكتب كوداً جيداً. تحتاج فقط للانضباط.

<Checklist>
  <CheckItem>شارك أنواع نماذج البيانات (DRY)</CheckItem>
  <CheckItem>غلف كل استجابة API بـ `ApiResponse<T>` موحد</CheckItem>
  <CheckItem>حدد أنواع الـ React Hooks (`useUser` مقابل `useQuery`)</CheckItem>
  <CheckItem>تحقق من جميع المدخلات أثناء التشغيل باستخدام **Zod**</CheckItem>
</Checklist>

---

**هل تحتاج مساعدة في بناء تطبيق آمن ومحكم؟** في NeoWhisper، نحن نبني تطبيقات جاهزة للإنتاج باستخدام TypeScript وNext.js. تحقق من [خدماتنا](/services?lang=ar) أو [تواصل معنا](/contact?lang=ar).
