---
title: "TypeScript ベストプラクティス：コンパイラと戦うのはもうやめよう"
date: "2026-01-29"
excerpt: "TypeScript は敵ではありません。Next.js + Node.js のフルスタック開発において、TypeScript を「ただの足枷」から「最強の武器」に変えるための実践的なパターンを紹介します。"
category: "TypeScript"
coverImage: "/images/typescript-best-practices-cover.png"
author:
  name: "NeoWhisper"
  picture: "/images/author.png"
---

正直に言うと、昔は TypeScript が嫌いでした。
機能を作る時間よりも、コンパイラを納得させるためにコードを書いている時間の方が長い気がしていたからです。

でも、**Next.js** と **Node.js** で本番アプリを運用していくうちに、ある事実に気づきました。

**TypeScript は、あなたと「深夜 3 時のデータベース崩壊」の間に立ちはだかる唯一の壁です。**

問題は TypeScript ではありません。多くのチュートリアルが「型の書き方」だけを教えて、「アプリケーションの書き方」を教えていないことが問題なのです。

ここでは、TypeScript をただのお飾りではなく、強力な武器にするための方法を紹介します。

---

<Step number="1" title="型定義を共有する (DRY)">

フロントエンドのフォルダに `User` 型があり、バックエンドのフォルダにも全く同じ `User` 型がある……これは間違いのもとです。
片方を変更してもう片方の更新を忘れると、バグがそのまま本番環境にデプロイされてしまいます。

**解決策：**
コアとなるデータモデルは、共有パッケージかフォルダにまとめましょう。

```ts
// packages/types/src/user.ts
export interface User {
  id: string;
  email: string;
  role: "admin" | "user";
}
```

これをすべての場所でインポートします。もし `role` の定義を変更すれば、プロジェクト全体のコードが赤くエラー表示されます。それが狙いです。

</Step>

<Step number="2" title="API レスポンスの形式を統一する">

「このエンドポイント、何を返すんだっけ？」

もし答えが「たしかオブジェクトだったかな……」なら、危険信号です。すべてのエンドポイントが、必ず同じ「形」でデータを返すように強制しましょう。

```ts
// types/api.ts
export interface ApiResponse<T> {
  data: T;
  success: boolean;
  error?: string;
}
```

**使用例:**

```ts
app.get("/users", async (req, res) => {
  const users = await db.users.findMany();

  // TypeScript がこの構造を強制します
  const response: ApiResponse<User[]> = {
    data: users,
    success: true,
  };

  res.json(response);
});
```

</Step>

<Step number="3" title="React Hooks でデータを厳密に型付けする">

よく見かける「犯罪的」なコードです：

```ts
// 悪い例
const { data } = useQuery(["user"], fetchUser);
// data は 'any' または 'unknown' になってしまう
```

これでは、TypeScript の恩恵を最後の最後で捨てているようなものです。こう書きましょう：

```ts
// 良い例
function useUser(id: string) {
  return useQuery<User>({
    queryKey: ["user", id],
    queryFn: () => fetchUser(id),
  });
}
```

これで、`data.` とタイプするだけで、VS Code が正しいプロパティを教えてくれます。

</Step>

<Step number="4" title="実行時の安全も確保する (Zod)">

TypeScript は素晴らしいですが、実行時には消えてしまいます。ユーザーがいいかげんな JSON データを送ってきたら、TypeScript は無力です。**Zod** が必要です。

API の境界線では、必ず Zod を使って検証しましょう。

```ts
import { z } from "zod";

const UserSchema = z.object({
  email: z.string().email(),
  age: z.number().min(18),
});

type UserInput = z.infer<typeof UserSchema>;

app.post("/users", (req, res) => {
  // 不正ならエラーを投げ、正しいなら型付きデータを返す
  const body = UserSchema.parse(req.body);

  saveUser(body);
});
```

これが「コンパイル時の安全性（TypeScript）」と「実行時の安全性（Zod）」のスイートスポットです。

</Step>

---

## 4つのチェックリスト

良いコードを書くのに、複雑な型パズルは必要ありません。

<Checklist>
  <CheckItem>データモデルの型を共有する (DRY)</CheckItem>
  <CheckItem>すべてのAPIレスポンスを `ApiResponse<T>` でラップする</CheckItem>
  <CheckItem>Hooksを型付けする（`useQuery` をラップする）</CheckItem>
  <CheckItem>実行時の入力をすべて **Zod** で検証する</CheckItem>
</Checklist>

---

**型安全なフルスタックアプリの開発支援が必要ですか？** NeoWhisperでは、TypeScript、Next.js、モダンなベストプラクティスを使った本番環境対応のアプリを開発しています。[サービス詳細](/services?lang=ja)をご覧いただくか、[お問い合わせ](/contact?lang=ja)からご相談ください。
